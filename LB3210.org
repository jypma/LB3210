* What's a microservice
** Definition
- micro: Give a definition here
- service: Give a definition here
** Philosophy
- Business needs evolve
- Team composition changes
- Services should be disposable (design for replacability *)
  - Rebuilt in 1-3 months

( * ) instead of design for reuse (DDD book)
** Service scope
- Service belongs to one team
- Data store belongs to one service
- Domain driven design
  - Naming things (resources, REST API)
  - Bounded Context
  - Ubiqutous Language
** Use cases 
- Embrace Conway's law: One system belongs to at most one team
- Monoliths are fine too
- Time to market and techincal debt vs. holistic design

* Design for resilience
** Your (or your colleague's) service will be down
P(everything working) = P(one service is working) ^ n_services

/Our service is up 99% of the time!/

Well, we have about 30 microservices, each with 3 copies. 
That means that 63% of the time, at least one service is down somewhere.
** Creating services
- Prefer shared (partitioned) data stores over single points of failure
- Always deploy more than 1 copy 
  - Investigate the need for a cluster-aware distributed framework
- Your service dashboard is as important as your public API
  - Have metrics on /everything/
- Be aware of your resource usage (dashboard! More on that later.)
- Use =Bulkhead= where applicable
*** Bulkhead
Semaphore with an optional timed queue in front
Picture here
** Consuming services
- Design for failure
  - Have methods/functions reflect doing I/O
  - Make time (and timeouts) explicit
  - Use =Circuit Breaker= where applicable
- Fail fast
  - =System.exit(1)= is a viable error handler
*** Circuit breaker
Smart state machine towards 1 backend
Picture here.
* Infrastructure architecture
** Partitioned data stores
*** Partitioned row stores
Each /row/ has a /key/ that specifies which partition(s) store data for that row. Data is typically stored in columns, following a schema.

- Open source: Cassandra
- Amazon: DynamoDB, Keyspaces
- Google: BigTable
- Azure: Cosmos DB (with Cassandra API)
*** Partitioned queues
Messages sent to a queue (sometimes called topic) are distributed to partitions, based on a /key/.
Messages typically small (some services have upper limit of 64kB).

- Open source: Kafka
- Amazon: SQS
- Google: Cloud Pub/Sub
- Azure: Storage Queue ( * ) , Service Bus ( * )

( * ) /not paritioned, size-limited/
*** Partitioned search
Full-text search is often important when dealing with data.

- Open source: Elasticsearch, SoLR
- Amazon: Hosted elasticsearch
- Google: Hosted elasticsearch
- Azure: Hosted elasticsearch
** Single-server data stores
- Avoid these unless specific requirements
- Many moving parts needed to make master/slave failover work
  - PostgreSQL: Multiple servers possible, but failures leak to the client. =pgBouncer= as alternative.
  - MariaDB: Multiple servers possible with failover
  - RabbitMQ: Multiple servers possible with failover, but failback doesn't work in Spring ([[https://jira.spring.io/browse/AMQP-318][AMQP-318]]) 
- If you choose these, make failover testing part of your CI

** Monitoring and alerting
- Logging need not be a cross-cutting concern
- Create monitored metrics instead
** Request tracing
** Deployment
*** Docker
*** Kubernetes
** Load balancer
* Data architecture
** Command query responsibility segregation
- CQRS: Have two separate data models (and split your API accordingly)
  - A /command/ model, for API calls that only change data (and do not return data)
  - A /query/ model, for API calls that only return data (and do not change data)

- Builds on CQS (Command query separation). One method can only do one of two things:
  - Perform a /command/, by having side effects (and not returning a value)
  - Perform a /query/, returning a value (and not having side effects)

** Event sourcing
 - Actual event sourcing (shared data store, materialized view into relational DB or Elasticsearch)
   - Event journal part of API?

** Pitfalls
- Service codependencies
  - Keep HTTP calls one way only
  - Plugin pattern
- Nested synchronous service calls
  - Added latency and failure possiblity
  - Avoid these with event sourcing
  - Replicate data instead, or call asynchronously when possible
* Security architecture
** Service-to-service authentication
- Mutual TLS
** User-to-service authentication
- OpenID Connect
** Authorization checks
- Prefer to keep internal to service
- Replicate user memberships through event sourcing
- Synchronous calls least favourable choice
* Software architecture
** Sprint Boot introduction
Intro here, present some useful abstractions (kafka?). Present plain Java libraries for some of the data stores.
** Annotation vs. functional style
 - Spring annotation style vs. functional style (e.g. [[https://www.exoscale.com/syslog/migrate-from-hystrix-to-resilience4j/][vavr and resiliance4j]]. JOOQ defaults to lambda transactions as well.)
   - Disadvantages of annotations: Discoverability, Composability, Testability
 - Show MVC annotations vs. akka-http lambdas
 - Resiliance4j also has [[https://resilience4j.readme.io/docs/getting-started-3][spring wrappers]]
** Useful modern Java features
- Lambdas (Java 8)
- Records (Java 14)
- Type-inferrerred variables (Java 11)
* Micro service life cycle
** Development
Which dependencies to mock, which to run
** Testing
Test pyramid
Unit tests (1 second)
Component tests of one component (10 seconds)
End-to-end tests between several components (1 minute)
Smoke tests in production, periodically, including external deps (you pick timing)
** Deployment
Automated pipeline to production
Forward deploy only
Infrastructure as code
* Strategy and team dynamics
** Microservices and agile
- Embrace change
- Team visibility
- Stakeholder support
- Team(s) in same time zone as stakeholders (which includes users)
  - Distributed users? distributed team!
** Migrating your monolith
- Chainsaw anti-pattern
- Strangler pattern
- Maven modules
** Do we need a separate dev/ops team? (no)
- Automate everything (rolling production deploy)
- Deploy in the morning, monitor your dashboards
- However, "infra tooling" or "platform" team can be helpful
* Getting your service used
** Public REST API 
** Public developer guide
** Public service dashboard
** Stay away from API gateways

* Interesting links
https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51
https://copyconstruct.medium.com/testing-in-production-the-safe-way-18ca102d0ef1

