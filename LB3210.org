#+TITLE: Microservices with Java and Spring Boot

* What's a microservice
** Definition
- /Service/
  * One operating system process (often on its own server)
  * Exposes an API (sometimes also a UI)
- /Micro/
  * Theory: It's small
  * Practice: There are many
  * Independently deployable
** Philosophy
- Business needs evolve
- Team composition changes
- Services should be disposable (design for replacability)
  * Rebuilt in 1-3 months
- Per service, use best technology matching experience and requirements 
** Service scope
- Service belongs to one team
- Data store belongs to one service
- Domain driven design
  * Naming things (resources, REST API)
  * Bounded Context
  * Ubiqutous Language
** Use cases 
- Embrace Conway's law: One system belongs to at most one team
- Monoliths are fine too
- Time to market and techincal debt vs. holistic design

* Design for resilience
** Your (or your colleague's) service will be down
P(everything working) = P(one service is working) ^ n_services

/Our service is up 99% of the time!/

Well, we have about 30 microservices, each with 3 copies. 
That means that 63% of the time, at least one service is down somewhere.
** Creating services
- Prefer sharded (partitioned) data stores over single points of failure
- Always deploy more than 1 copy 
  * Investigate the need for a cluster-aware distributed framework
- Your service dashboard is as important as your public API
  * Have metrics on /everything/
- Be aware of your resource usage (dashboard! More on that later.)
- Use =Bulkhead= where applicable
*** Bulkhead
A single resource pool is covering multiple types of application requests

[[file:graphics/svg/without_bulkhead.png]]
*** Bulkhead in place
- Semaphore with an optional timed queue in front
- Other parts of the resource pool are still accessible

[[file:graphics/svg/with_bulkhead.png]]
** Consuming services
- Design for failure
  * Have methods/functions reflect doing I/O
  * Make time (and timeouts) explicit
  * Use =Circuit Breaker= where applicable
- Fail fast
  * =System.exit(1)= is a viable error handler
- Idempotency for all incoming data
*** Circuit breaker
Smart state machine towards 1 backend
Picture here.
* Infrastructure architecture
** Partitioned data stores
*** Partitioned row stores
Each /row/ has a /key/ that specifies which partition(s) store data for that row. Data is typically stored in columns, following a schema.

- Open source: Cassandra
- Amazon: DynamoDB, Keyspaces
- Google: BigTable
- Azure: Cosmos DB (with Cassandra API)
*** Partitioned queues
Messages sent to a queue (sometimes called topic) are distributed to partitions, based on a /key/.
Messages typically small (some services have upper limit of 64kB).

- Open source: Kafka
- Amazon: SQS
- Google: Cloud Pub/Sub
- Azure: Storage Queue ( * ) , Service Bus ( * )

( * ) /not paritioned, size-limited/
*** Partitioned search
Full-text search is often important when dealing with data.

- Open source: Elasticsearch, SoLR
- Amazon: Hosted elasticsearch
- Google: Hosted elasticsearch
- Azure: Hosted elasticsearch
** Single-server data stores
- Avoid these unless specific requirements
- Many moving parts needed to make master/slave failover work
  * PostgreSQL: Multiple servers possible, but failures leak to the client. =pgBouncer= as alternative.
  * MariaDB: Multiple servers possible with failover
  * RabbitMQ: Multiple servers possible with failover, but failback doesn't work in Spring ([[https://jira.spring.io/browse/AMQP-318][AMQP-318]]) 
- If you choose these, make failover testing part of your CI
*** RabbitMQ
- Message queue with focus on performance
- Original architecture single-server
  * Later extended with /Mirror Queues/ 
  * Extended with /Quorum Queues/ in 2019 (raft)
    + No message TTL, no message priorities
    + All cluster members have all data
    + All messages in memory! (in addition to storage)
*** RabbitMQ Data consistency
- AMQP "transaction"
  * Covers only a single queue
  * "Slow" (fsync for every transaction)
- /Publisher confirms/
  * Asynchronous message from RabbitMQ to client (after fsync): =basic.ack= or =basic.nack=
  * Impossible to predictably deal with lost broker connection (risk duplicate, risk lost messages)
- Manual /Consumer acknowledgement/
  * Consumer sends message to RabbitMQ to confirm handling of message is complete
  * =basic.ack=, =basic.nack(requeue)=, =basic.nack(no requeue)=
  * This is async, so no guarantee that the server receives it
(* something something 2 generals)
** Monitoring and alerting
- Logging need not be a cross-cutting concern
- Create monitored metrics instead
** Request tracing
TODO write about Jaeger and Zipkin
** Configuration
- configuration file changes
  * kubernetes
  * hot reloading? Not in spring boot (watch file and shutdown instead)
- environment variables for service injection: don't do it (ordering issues)
  * use dns instead (e.g. dns-java, akka discovery, [...])
** Deployment
*** Docker
- Limited to linux in this course
- Lightweight layer over native cgroups isolation
- Instant process startup
*** Docker-compose
- Groups several docker containers and storage
- Ideal for local testing
- TODO show example from demo project
*** Kubernetes
- Manages a cluster of distributed docker containers with copies
- Ideal for production
- Configure Memory requests and limits
- Configure CPU requests
- Get comfortable getting thread and heap dumps
- Heap dump on out of memory (this /will/ happen)
  * =-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/dumps= to an =emptyDir= volume
** Load balancer
- TODO write about kubernetes ingres (typically nginx)
- TODO write about haproxy load balancer (tcp-level)
* Data architecture
** Command query responsibility segregation
- CQRS: Have two separate data models (and split your API accordingly)
  * A /command/ model, for API calls that only change data (and do not return data)
  * A /query/ model, for API calls that only return data (and do not change data)

- Builds on CQS (Command query separation). One method can only do one of two things:
  * Perform a /command/, by having side effects (and not returning a value)
  * Perform a /query/, returning a value (and not having side effects)

** Event sourcing
 - Actual event sourcing (shared data store, materialized view into relational DB or Elasticsearch)
   * Event journal part of API?

** Pitfalls
- Service codependencies
  * Keep HTTP calls one way only
  * Plugin pattern
- Nested synchronous service calls
  * Added latency and failure possiblity
  * Avoid these with event sourcing
  * Replicate data instead, or call asynchronously when possible
* Security architecture
** Service-to-service authentication
- Mutual TLS
** User-to-service authentication
- OpenID Connect
** Authorization checks
- Prefer to keep internal to service
- Replicate user memberships through event sourcing
- Synchronous calls least favourable choice
* Software architecture
** Spring Boot introduction
Intro here, present some useful abstractions (kafka?). Lots of "sensible defaults" (or "magic mystery"). Infrastructure beans
Present plain Java libraries for some of the data stores.
** Annotation vs. functional style
- Spring annotation style vs. functional style (e.g. [[https://www.exoscale.com/syslog/migrate-from-hystrix-to-resilience4j/][vavr and resiliance4j]]. JOOQ defaults to lambda transactions as well.)
   * Disadvantages of annotations: Discoverability, Composability, Testability
- Show MVC annotations vs. akka-http lambdas
- Resiliance4j also has [[https://resilience4j.readme.io/docs/getting-started-3][spring wrappers]]
** Useful modern Java features
- Lambdas (Java 8)
- Records (Java 14)
  * JOOQ was [[https://github.com/jOOQ/jOOQ/issues/10287][just]] updated with record support for POJOs (for 3.15.0)
- Type-inferrerred variables (Java 11)
** Functional programming and immutability: VAVR
TODO describe VAVR, with code
** Relational databases
*** Migration management: Flyway
TODO describe Flyway, link to code
*** Interacting with data: JOOQ
TODO describe JOOQ, link to code
** RabbitMQ
TODO make some code
*** Spring Boot RabbitMQ
- Doesn't wait for publisher confirms by default
- Can't fail application if RabbitMQ is/goes down
- Consume messages: =@RabbitListener=
  * Automatically sends =basic:ack= after method returns, or =basic:nack= 
TODO link to code
- Produce messages
* Micro service life cycle
** Development
Which dependencies to mock, which to run
** Testing
Test pyramid
Unit tests (1 second)
Component tests of one component (10 seconds)
End-to-end tests between several components (1 minute)
Smoke tests in production, periodically, including external deps (you pick timing)
** Deployment
Automated pipeline to production
Forward deploy only
Infrastructure as code
* Strategy and team dynamics
** Microservices and agile
- Embrace change
- Team visibility
- Stakeholder support
- Team(s) in same time zone as stakeholders (which includes users)
  * Distributed users? distributed team!
** Migrating your monolith
- Chainsaw anti-pattern
- Strangler pattern
- Maven modules
** Do we need a separate dev/ops team? (no)
- Automate everything (rolling production deploy)
- Deploy in the morning, monitor your dashboards
- However, "infra tooling" or "platform" team can be helpful
* Getting your service used
** Public REST API 
- RAML vs OpenAPI
  * RAML more advanced, easier to write by hand
  * OpenAPI more tooling support
- Role of an XSD in a an XML API 
- Create JSON schemas for everything
** Public developer guide
** Public service dashboard
** Stay away from API gateways

* Interesting links
https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51
https://copyconstruct.medium.com/testing-in-production-the-safe-way-18ca102d0ef1

* Notes
